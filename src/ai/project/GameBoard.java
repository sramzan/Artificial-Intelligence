/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ai.project;

import java.awt.Choice;
import java.awt.Color;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.JButton;

/**
 *
 * @author Sean
 */
public class GameBoard extends javax.swing.JFrame {

    /**
     * Creates new form GameBoard
     */
    public GameBoard() {
        // Sets up the basic layout and structure of the gameboard
        initComponents(); // builds the inital GUI
        setAllInitialRelativeLoc(); // sets the location for all squares in the gameboard
        setChoicesForPlayerColorChoice(); // sets the drop-down so that the player can choose a color of his/her choice
        storeAllSquaresInArr(); // store all squares on the baord in a data strucutre in order to keep track of the state of the board
        setInitialPlayers(); // set the intial starting positions & properties of the white & black players
        setActionForAllSquares(); // add the action listener to all squares on the board
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // builds the inital GUI which was built in the GUI editor. The squares used are custom made, and all logic is set in the constructor
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        choice1 = new java.awt.Choice();
        jPanel1 = new javax.swing.JPanel();
        square0 = new ai.project.GameSquare();
        square1 = new ai.project.GameSquare();
        square2 = new ai.project.GameSquare();
        square3 = new ai.project.GameSquare();
        square4 = new ai.project.GameSquare();
        square5 = new ai.project.GameSquare();
        square6 = new ai.project.GameSquare();
        square7 = new ai.project.GameSquare();
        square8 = new ai.project.GameSquare();
        square9 = new ai.project.GameSquare();
        square10 = new ai.project.GameSquare();
        square11 = new ai.project.GameSquare();
        square12 = new ai.project.GameSquare();
        square13 = new ai.project.GameSquare();
        square14 = new ai.project.GameSquare();
        square15 = new ai.project.GameSquare();
        square16 = new ai.project.GameSquare();
        square17 = new ai.project.GameSquare();
        square18 = new ai.project.GameSquare();
        square19 = new ai.project.GameSquare();
        square20 = new ai.project.GameSquare();
        square21 = new ai.project.GameSquare();
        square22 = new ai.project.GameSquare();
        square23 = new ai.project.GameSquare();
        square24 = new ai.project.GameSquare();
        playerColorChoice = new java.awt.Choice();
        label1 = new java.awt.Label();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setLayout(new java.awt.GridLayout(5, 5, 1, 1));

        square0.setBackground(java.awt.Color.lightGray);
        square0.setOpaque(true);
        jPanel1.add(square0);

        square1.setBackground(new java.awt.Color(0, 0, 0));
        square1.setText("black_1");
        square1.setOpaque(true);
        jPanel1.add(square1);

        square2.setBackground(new java.awt.Color(0, 0, 0));
        square2.setText("black_2");
        square2.setOpaque(true);
        jPanel1.add(square2);

        square3.setBackground(new java.awt.Color(0, 0, 0));
        square3.setText("black_3");
        square3.setOpaque(true);
        jPanel1.add(square3);

        square4.setBackground(java.awt.Color.lightGray);
        square4.setOpaque(true);
        jPanel1.add(square4);

        square5.setText("white_1");
        square5.setOpaque(true);
        jPanel1.add(square5);

        square6.setBackground(java.awt.Color.lightGray);
        square6.setOpaque(true);
        jPanel1.add(square6);

        square7.setBackground(java.awt.Color.lightGray);
        square7.setOpaque(true);
        jPanel1.add(square7);

        square8.setBackground(java.awt.Color.lightGray);
        square8.setOpaque(true);
        jPanel1.add(square8);

        square9.setText("white_4");
        square9.setOpaque(true);
        jPanel1.add(square9);

        square10.setText("white_2");
        square10.setOpaque(true);
        jPanel1.add(square10);

        square11.setBackground(java.awt.Color.lightGray);
        square11.setOpaque(true);
        jPanel1.add(square11);

        square12.setBackground(java.awt.Color.lightGray);
        square12.setOpaque(true);
        jPanel1.add(square12);

        square13.setBackground(java.awt.Color.lightGray);
        square13.setOpaque(true);
        jPanel1.add(square13);

        square14.setText("white_5");
        square14.setOpaque(true);
        jPanel1.add(square14);

        square15.setText("white_3");
        square15.setOpaque(true);
        jPanel1.add(square15);

        square16.setBackground(java.awt.Color.lightGray);
        square16.setOpaque(true);
        jPanel1.add(square16);

        square17.setBackground(java.awt.Color.lightGray);
        square17.setOpaque(true);
        jPanel1.add(square17);

        square18.setBackground(java.awt.Color.lightGray);
        square18.setOpaque(true);
        jPanel1.add(square18);

        square19.setText("white_6");
        square19.setOpaque(true);
        jPanel1.add(square19);

        square20.setBackground(java.awt.Color.lightGray);
        square20.setOpaque(true);
        jPanel1.add(square20);

        square21.setBackground(new java.awt.Color(0, 0, 0));
        square21.setText("black_4");
        square21.setOpaque(true);
        jPanel1.add(square21);

        square22.setBackground(new java.awt.Color(0, 0, 0));
        square22.setText("black_5");
        square22.setOpaque(true);
        jPanel1.add(square22);

        square23.setBackground(new java.awt.Color(0, 0, 0));
        square23.setText("black_6");
        square23.setOpaque(true);
        jPanel1.add(square23);

        square24.setBackground(java.awt.Color.lightGray);
        square24.setOpaque(true);
        jPanel1.add(square24);

        label1.setText("Player Color");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 767, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(playerColorChoice, javax.swing.GroupLayout.PREFERRED_SIZE, 171, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(56, 56, 56)
                        .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 548, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(playerColorChoice, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GameBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GameBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GameBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GameBoard.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                //setCorrespondingGameConfigs();
                GameBoard gb = new GameBoard(); // Creates a new GameBoard, and 
                gb.setVisible(true); // allows the user to see the UI
            }
        });
        while (!gameOver){ // Run until the game is over
            try{
                if(playerColorChoiceSet){ // Checks to see if the user has picked a color choice
                   if (isFirstRun){ // Checks to see if this is the first run, if so, apply correct logic as to who goes first (player or AI)
                       if (playerColor.equals("White")){ // If the player is white, the AI goes first
                           //AI has to get the first move
                           System.out.println("Getting move via Alpha Beta");
                           isFirstRun = false; // first run is over
                           moveUsingAlphaBeta(); // move a piece using the Alpha Beta Algorithm if the player chose to be White
                       }else{
                           isFirstRun = false;
                           isPlayerTurn = true; // let the player move a piece first if the player chose to be Black
                       }
                   }

                   if (isPlayerTurn){ // Wait for the player to make a move -- *** THIS SEEMS TO BE A VERY ODD ISSUE FOR THE UI, EVERYTHING WAS WORKING BEFORE THIS WAITING PERIOD WAS IMPEMENTED/STILL WORKS DURING A DEBUG
                       System.out.println("Player's Turn...");
                       while(isPlayerTurn){
                           
                       }
//                       System.out.println("Player's Turn...");
                      // wait
                   }else{
                       System.out.println("Getting move via Alpha Beta");
                       moveUsingAlphaBeta(); // If not the player's turn, make a move using Alph Beta
                       isPlayerTurn = true;  // Signal that it is no longer the AI's turn, but the Human's turn
                   }
                }
            }catch(Exception e){
                System.out.println("Issue in main function " + e); // Catches any issue that may arise
            }
        }

    }
    
    public static Boolean isCutOffState(int depth){
        /*
         - Cuttoff function for use with the Alpha Beta Logic
         - It should cutoff when the depth of the tree has grown to be 1000 or more (to avoid a stackoverflow), or if 10 seconds has elapsed during a search
        */
       
        if (depth >= 1000) // return true if the depth of the tree has grown to be 1000 levels deep or deeper
            return true;
        float timeElapsed = (float) ((System.nanoTime() - startTime) / 1E9 ); // calculate the total elapsed time
        if (timeElapsed>= 10.0f){ // return true if 10 seconds has elasped
//            System.out.println("CUTOFF HIT");
            return true;
        }
        return false; // return false if a cutoff conition has not been met
    }
    
    public static Map<Integer, ArrayList<GameSquare>> Eval(LinkedHashMap<Point, GameSquare> pieces, LinkedHashMap<Point, GameSquare> enemies, LinkedHashMap<Point, GameSquare> squares) throws CloneNotSupportedException{
        /*
         - @param1 : current player's pieces
         - @param2 : current enemy pieces
         - @param3 : current state of the GameBoard
         - This function determine an appropriate game state to return due to a cutoff occuring
         - The logic here follows that the piece with the fewest amount of moves should move
            - The reason is that the AI should try to avoid being caught in a sitatuation where it gets trapped
            - As such, the piece with the fewest amount of moves possible, will make it's first available move
            - If all pieces have the same amount of moves available, the last piece checked will be moved first (when the AI rmoves first, this move will most likely be the same consistently)
         - The return type is consistent with the Alpha Beta Algorithm
            - @return Map<v, ArrayList<movedToBeMade>>
        */
//        enemyPieces  = getDeepCopy(enemies);
//        playerPieces = getDeepCopy(pieces);
        int numMovesPossible = 8; // setting to max number of moves possible per piece
        Map<Integer, ArrayList<GameSquare>> returnMove = new HashMap(); // the return map of the eval function
        ArrayList<GameSquare> moveToMake = new ArrayList(); // will hold the move to make based on the logic below
        for (GameSquare piece : pieces.values()){ // go through all player pieces
            if(piece.pieceColor().equals("none")){ // this is a over-protective check to ensure nothing unforseen has happened (i.e. color of player/enemy gets mixed up)
                System.out.println("Gray piece was found in the player's pieces... please investigate");
                continue;
            }
                
           LinkedHashMap<GameSquare, Boolean> possibleMoves = getListOfPossibleMoves(piece, pieces, enemies, squares); // Based on the piece in question, aggregate all possible moves for the specifc piece
           
           if (numMovesPossible >= possibleMoves.size() && possibleMoves.size() > 0){ // Checking to see if the number of moves a piece can make it less than a piece before it
               numMovesPossible = possibleMoves.size(); // set the smallest number of moves found so far
               Map.Entry<GameSquare, Boolean> entry = possibleMoves.entrySet().iterator().next(); // extract the move to make
               moveToMake.add(piece); // add the location of the current piece
               moveToMake.add(entry.getKey()); // add the location of where the piece should move to 
           }
        }
        
        if (moveToMake.size() > 0){
            returnMove.put(infinity/2, moveToMake); // set the return map to hold the v value and the matching moves -- may consider changing v value
        }else
            returnMove.put(infinity/2, null); // in the rare occassion that no moves exist for any pieces, store null as the movement so that algorithm knows that no moves exist
        
        return returnMove; // @return Map<v, ArrayList<movedToBeMade>>
    }
    
    public static void saveCurrentEnv(){
        /*
         - Saves the env as is before starting a run in the algorithm
         - This is to ensure the move made is done on the existing state of the gameboard, and not in a state predicted by the algorithm
        */
        try{
            System.out.println("Saving current env...");
            savedPlayerPieces = getDeepCopy(playerPieces); // The player pieces get copied over by value and not by reference, that way there is no link to the original data structure
            savedEnemyPieces  = getDeepCopy(enemyPieces);  // The enemy pieces get copied over by value and not by reference, that way there is no link to the original data structure
            savedGameBoard    = getDeepCopy(squares);      // The gameboard gets copied over by value and not by reference, that way there is no link to the original data structure
//            playerPiecesBeforeRun = playerPieces;
//            enemyPiecesBeforeRun  = enemyPieces;
            
            if (playerColor.equals("White")){ // Store the current white & black players respectively based on the color of the player for the same reason above
                whitePlayers = playerPieces; // If the player is white, the whitePlayers are updated
                blackPlayers = enemyPieces;  // If the player is black, the blackPlayers are updated
            }else{
                whitePlayers = enemyPieces;  // vice versa
                blackPlayers = playerPieces; // vice versa
            }
        }
        catch (Exception e){
            System.out.println("Issue saving current state of board"); // Notifies us of any issues
        }
    }
    
    public static synchronized void flipConfigsForAIorPlayer(LinkedHashMap<Point, GameSquare> currentPieces, LinkedHashMap<Point, GameSquare> currentEnemies) throws CloneNotSupportedException{
        /*
         - @param1 : current player pieces
         _ @param2 : current enemy pieces
         - This functions flips the configs of the player and the AI 
            - This is done b/c the role of player and enemy is flipped for when the AI & player are choosing a move
            - The logic essentially emulates the perspective of the entity choosing a move 
            - i.e. if the player is intially White, when the AI looks for a move, the player becomes Black & the enemy becomes white
            - All configs are changed accordingly (the data strucutres, variables, etc.)
        - There is no return for this, but it sets a data structure that holds the changedPieces/data strucutures
            - This was chosen over a return as to not create more memory demands, but keep a constant data strucutre that holds the changed pieces 
            - It is then the job of the caller to set the playerPieces & enemyPieces after each call of this function
        */
//        LinkedHashMap<Point, GameSquare> tmpPlayerPieces = getDeepCopy(playerPieces);
//        ArrayList<LinkedHashMap<Point, GameSquare>> returnVals = new ArrayList();
        if (playerColor.equals("White")){ // If the player is White, change to Black. If the enemy is Black, change to White
            playerColor = "Black";
            enemyColor  = "White";
        }else{
            playerColor = "White";
            enemyColor  = "Black";
        }
        LinkedHashMap<Point, GameSquare> tmpEnemies = currentEnemies; // Match up the corresponding data structures due to the flip above
        currentEnemies = currentPieces; 
        currentPieces  = tmpEnemies;
        
        changedPieces.clear(); // clear any changes that may exist in the changed pieces
        changedPieces.add(currentPieces);  // add the current player pieces (again respective to the caller) to the changedPieces arraylist as index 0
        changedPieces.add(currentEnemies); // add the current enemy pieces (again respective to the caller) to the changedPieces arraylist as index 0
//        
           
        
//        System.out.println("Setting configs...");
//        playerColor = (playerColor.equals("White")) ? "Black" : "White";
//        enemyColor  = (playerColor.equals("White")) ? "Black" : "White";
//        setCorrespondingGameConfigs();
    }
    
    public static void moveUsingAlphaBeta() throws CloneNotSupportedException{
        /*
         - This is the start of the Alpha Beta Algorithm
         - It does not return a value, as the setup of the game suggested making the move after the algorithm decided on one, was easier
         - The algorithm keeps track of the start of the game, and makes the move accordingly
         - The logic of the algorithm follows suit with what we have learned in class, with slight modifications to adapt to the setup of the logic in this code
        */
        
//        GameSquare v = new GameSquare();
//        LinkedHashMap<Point, GameSquare> currentStateOfBoard = squares;
        String intialPlayerColor = playerColor; // Preserves the color of the user (it will be switched so the AI's perspective is given to the game)
        System.out.println("Starting Alpha Beta Algo Search...");
        startTime = System.nanoTime(); // reset startTime to the current time so that the cutoff can occur after 10seconds
        Map<Integer, ArrayList<GameSquare>> v = new HashMap(); // Will store the return of the entire algorithm (the v value, and corresponding move)
        saveCurrentEnv(); // save the current env as defined in the function
        flipConfigsForAIorPlayer(savedPlayerPieces, savedEnemyPieces); // flip the configs to flip between the perspective of the user & the AI as defined in the function
        savedPlayerPieces = changedPieces.get(0); // update the player list to that determined by the function above
        savedEnemyPieces  = changedPieces.get(1); // update the enemy list to that determined by the function above
        
        v = MAX_VALUE(savedPlayerPieces, savedEnemyPieces, savedGameBoard, -infinity, infinity,0); // The intial start of the Alpha Beta Algorithm's recursive calls 
        Map.Entry<Integer, ArrayList<GameSquare>> entry = v.entrySet().iterator().next(); // get the entry of the what was returned
        // *** It is worth noting that the move for the returned v value is included as the value in this key,value pair. As such, we just need to move according to what the value says
        
//        squares      = copiedGameBoard;
//        playerPieces = copiedPlayerPieces;
//        enemyPieces  = copiedEnemyPieces;
//        LinkedHashMap<Point, GameSquare> tmpEnemies = enemyPieces;
//        enemyPieces  = playerPieces;
//        playerPieces = tmpEnemies;
        // making sure everything is setup for the AI run here
        
        // Ensurinng the color perspective, and respective data structures are still in line with the AI's perspective
        if (intialPlayerColor.equals("White")){ // if the intial player's color was White, then make sure the current playerColor is Black. The ensure the playerPieces & enemyPieces are set accordingly
            playerColor = "Black";
            enemyColor  = "White";
            playerPieces = blackPlayers;
            enemyPieces  = whitePlayers;
        }
        else{ // if the intial player's color was Black, then make sure the current playerColor is White. The ensure the playerPieces & enemyPieces are set accordingly
            playerColor = "White";
            enemyColor  = "Black";
            playerPieces = whitePlayers;
            enemyPieces  = blackPlayers;
        }
        
        
        if (entry.getValue() != null){ // takes care of the instance when there may not be any available moves. If so, do not move. But, if a move exists, make the necessary move
            GameSquare oldLoc = entry.getValue().get(0); // The piece being moved (the old location)
            GameSquare newLoc = entry.getValue().get(1); // The destination of where the piece is to be moved to (the new location)
            move(oldLoc, newLoc); // Move the piece, and update the GUI
            System.out.println("Move " + oldLoc.pieceColor() + " piece at " + oldLoc.getRelativeLoc() + " to new location at " + newLoc.getRelativeLoc());
            // check what the player and enemy pieces are here
        }
        
        // The below will check to to see if someone has won. This also handles the case that when a person moves, and both players in winning state, the player wins
        checkForWinningGameState(playerPieces, enemyPieces); // Checks to see if the move the AI makes causes a winning condition for itself or the player. If so, end the game
        if (playerWins){ // remember the "player" in this perspective is the AI, and its enemy is the player (explains the variable names below)
            System.out.println("GAME OVER! " + playerColor + "has won");
            gameOver = true; // ends the game
            return;
        }
        
        if (enemyWins){ // remember the "player" in this perspective is the AI, and its enemy is the player (explains the variable names below)
            System.out.println("GAME OVER! " + playerColor + "has won");
            gameOver = true; // ends the game
            return;
        }
        
        
        // By this point, the AI has made its move, and a winning condition does not exist, so we flip the configs/control back to the player
        LinkedHashMap<Point, GameSquare> tmpPlayers = new LinkedHashMap();
        if (intialPlayerColor.equals("White")){
            playerColor = "White";
            enemyColor  = "Black";
        }
        else{
            playerColor = "Black";
            enemyColor  = "White";
        }
        tmpPlayers  = enemyPieces; 
        enemyPieces = playerPieces;
        playerPieces = tmpPlayers;
//        playerPieces = playerPiecesBeforeRun;
//        enemyPieces  = enemyPiecesBeforeRun;
//        playerColor  = (intialPlayerColor.equals("White")) ? "White" : "Black";
//        enemyColor   = (intialPlayerColor.equals("White")) ? "Black" : "White";
//        flipConfigsForAIorPlayer();
//        return the action in ACTIONS(state) with value v - MAY HAVE TO DO THIS
    }
    
    public static synchronized Map<Integer, ArrayList<GameSquare>> MAX_VALUE(LinkedHashMap<Point, GameSquare> currentPlayerPiecesState, LinkedHashMap<Point, GameSquare> currentEnemyPiecesState, LinkedHashMap<Point, GameSquare> currentBoardSquareLayout, int alpha, int beta, int depth){
        /*
         - @param1 : current pieces for the player (the player is the AI as this is from the AI's perspective, and the AI is the MAX player)
         - @param2 : current enemy pieces (the enemy is the user as this is from the AI's perspective, and the user is the MIN player)
         - @param3 : current layout of the board (same from the perspective of the AI & user)
         - @param4 : alpha value (initally set to -infinity)
         - @param5 : beta value (intially set to infinity)
         - @param6 : current depth (initially 0)
        
         - @return : Map< v, ArrayList<pieceToBeMoved, destinationForThePieceToBeMoved>
        
        - This the MAX function, and has the behavior of the MAX function studied in class
            - The only difference is that the return type is different in order to accomodate the code setup
            - A v value is still returned, and analyzed
                - It is the key value of the mapping returned
            - The value associated with the key is the move to be made
        */

        // setting the v value here due to code strucutre demands, but is stil used int the traditional Alpha Beta manner 
        int v = -infinity;
        ArrayList<GameSquare> defaultMove = new ArrayList();
        
        try{
            // Need to copy and preserve the layout of the board, the enemy & player pieces for each run of the function
            // This will ensure that each recursive call receives the correct state of the board, will all configs properly set AND that the intial call has an env that is not touched
                // This is to say that when the Alpha Beta algorithm decides on the move to make, it will be made under the correct coditions
            LinkedHashMap<Point, GameSquare> intialStateOfPieces      = getDeepCopy(currentPlayerPiecesState);
            LinkedHashMap<Point, GameSquare> intialStateOfEnemyPieces = getDeepCopy(currentEnemyPiecesState);
            LinkedHashMap<Point, GameSquare> intialStateOfSquares     = getDeepCopy(currentBoardSquareLayout);
            LinkedHashMap<Point, GameSquare> copiedPlayerPieces       = getDeepCopy(intialStateOfPieces);
            LinkedHashMap<Point, GameSquare> copiedEnemyPieces        = getDeepCopy(intialStateOfEnemyPieces);
            LinkedHashMap<Point, GameSquare> copiedSquares            = getDeepCopy(intialStateOfSquares);
            
//            playerPieces = getDeepCopy(intialStateOfPieces); // need to reset to the intial passed in value so that every move could be evaluated equally
//            enemyPieces  = getDeepCopy(intialStateOfEnemyPieces);
            
             // if TERMINAL-TEST(state) then return UTILITY(state)
            checkForWinningGameState(copiedPlayerPieces, copiedEnemyPieces);
            if (playerWins || enemyWins){ // This is essentially the terminal test... a terminal node is defined as a winning or losing state. Utility Value : 100 for win, -100 for loss
                Map <Integer, ArrayList<GameSquare>> utilityVal = new HashMap();
                int terminalVal = (playerWins) ? 100 : -100;
                utilityVal.put(new Integer(terminalVal), null);
                return utilityVal;
            }

            //if CUTOFF-TEST(state, depth) then return EVAL(state)
            if (isCutOffState(depth)){ // checks if cutoff state
//                System.out.println("MAX_FUNC: Before EVAL");
                return Eval(copiedPlayerPieces, copiedEnemyPieces, copiedSquares); // returns the eval function as described in the function if the cutoff state has occurred

            }


            // for every piece in the players current pieces
            for (Map.Entry<Point,GameSquare> intialEntry : currentPlayerPiecesState.entrySet()){
                GameSquare oldLoc = intialEntry.getValue().clone();
                LinkedHashMap<GameSquare, Boolean> possibleMovesForSquare = getListOfPossibleMoves(oldLoc, copiedPlayerPieces, copiedEnemyPieces, copiedSquares); // get list of possible moves for the piece
                
                // for every valid move in the list of valid moves for the current piece in question
                for (GameSquare newLoc : possibleMovesForSquare.keySet()){
                    GameSquare newLocUntouched = newLoc.clone(); // saves the untouched new location
                    defaultMove.clear(); // clear default move
                    oldLoc = intialEntry.getValue().clone(); // saves the the untouched old location
                    copiedPlayerPieces = getDeepCopy(intialStateOfPieces); // need to reset to the intial passed in pieces so that every move could be evaluated equally
                    copiedEnemyPieces  = getDeepCopy(intialStateOfEnemyPieces); // need to reset to the intial passed in enemies so that every move could be evaluated equally
                    copiedSquares      = getDeepCopy(intialStateOfSquares); // need to reset to the intial passed in state of board so that every move could be evaluated equally
    
                    // moves the pieces according to the valid move WITHOUT updating the GUIT
                    moveWithoutUpdatingGUI(oldLoc, newLoc, copiedPlayerPieces, copiedEnemyPieces, copiedSquares);
                    copiedPlayerPieces = changedPieces.get(0); // update the player list based on any changes in the move 
                    copiedEnemyPieces  = changedPieces.get(1); // update the enemy list based on any changes in the move 
                    copiedSquares      = changedPieces.get(2); // update the state of the board based on any changes in the move
                    
                    // just as in the intial call, flip the perspective from AI as the player, to the user as the player for the MIN call
                    flipConfigsForAIorPlayer(copiedPlayerPieces, copiedEnemyPieces);
                    copiedPlayerPieces = changedPieces.get(0);
                    copiedEnemyPieces  = changedPieces.get(1);
                    
                    Map<Integer, ArrayList<GameSquare>> resultOfMin = MIN_VALUE(copiedPlayerPieces, copiedEnemyPieces, copiedSquares, alpha, beta, depth+1); // get the resulting v value & move to get that value for the min player
                    
                    // just as in the intial call, flip the perspective from the user as the player to the AI as the player to finished the function call
                    flipConfigsForAIorPlayer(copiedPlayerPieces, copiedEnemyPieces);
                    copiedPlayerPieces = changedPieces.get(0);
                    copiedEnemyPieces  = changedPieces.get(1);
                    
                    Map.Entry<Integer, ArrayList<GameSquare>> entry = resultOfMin.entrySet().iterator().next(); // extract the v value from the pair returned
                    int returnValOfMIN_VALUE = entry.getKey().intValue();
                    // v ← MAX(v, MIN-VALUE(RESULT(state, a), α, β, depth+1))
                    v = Math.max(v, returnValOfMIN_VALUE); // do the comparison
                    // should I reset the player, enemy, and all squares before running this again?

                    oldLoc = intialEntry.getValue().clone();
                    newLoc = newLocUntouched;
    //                if v ≥ β then return v
                    if (v >= beta){
                        ArrayList<GameSquare> moveToMake = new ArrayList<>(Arrays.asList(oldLoc, newLoc));
                        Map <Integer, ArrayList<GameSquare>> pairToReturn = new HashMap();
                        pairToReturn.put(v, moveToMake);
                        return pairToReturn;
                    }
                    
    //                α← MAX(α, v)
                    alpha = Math.max(alpha, v); 
                    defaultMove.add(oldLoc);
                    defaultMove.add(newLoc);
                }
            }
        }catch (Exception e){
            System.out.println("***************************************");
            System.out.println("ERROR in MAX_FUNC");
            System.out.println("Issue:  "+ e);
            System.out.println("PlayerColor: " + playerColor);
//            System.out.println(playerPieces);
            System.out.println("EnemyColor: " + playerColor);
//            System.out.println(enemyPieces);
//            System.out.println(resultOfMin);
            System.out.println("depth: " + depth);
            System.out.println("***************************************");
        }
        Map <Integer, ArrayList<GameSquare>> pairToReturn = new HashMap();
        pairToReturn.put(v, defaultMove);
        return pairToReturn;
    }
    
    public static synchronized Map<Integer, ArrayList<GameSquare>> MIN_VALUE(LinkedHashMap<Point, GameSquare> currentPiecesState, LinkedHashMap<Point, GameSquare> currentEnemyPiecesState, LinkedHashMap<Point, GameSquare> currentBoardSquareLayout, int alpha, int beta, int depth){
//        if TERMINAL-TEST(state) then return UTILITY(state)
//        System.out.println("MIN_FUNC: starting");
        int v = infinity;
//        System.out.println("MIN_FUNC: set v");
        ArrayList<GameSquare> defaultMove = new ArrayList();
//        System.out.println("MIN_FUNC: Set default move array");
        
        try{
            
            LinkedHashMap<Point, GameSquare> intialStateOfPieces      = getDeepCopy(currentPiecesState);
            LinkedHashMap<Point, GameSquare> intialStateOfEnemyPieces = getDeepCopy(currentEnemyPiecesState);
            LinkedHashMap<Point, GameSquare> intialStateOfSquares     = getDeepCopy(currentBoardSquareLayout);
            
            LinkedHashMap<Point, GameSquare> copiedPlayerPieces       = getDeepCopy(intialStateOfPieces);
            LinkedHashMap<Point, GameSquare> copiedEnemyPieces        = getDeepCopy(intialStateOfEnemyPieces);
            LinkedHashMap<Point, GameSquare> copiedSquares            = getDeepCopy(intialStateOfSquares);
//            playerPieces = getDeepCopy(intialStateOfPieces); // need to reset to the intial passed in value so that every move could be evaluated equally
//            enemyPieces  = getDeepCopy(intialStateOfEnemyPieces);
//            System.out.println("MIN_FUNC: Checking for winner");
            checkForWinningGameState(copiedPlayerPieces, copiedEnemyPieces);
            if (playerWins || enemyWins){
//                System.out.println("MIN_FUNC: Someone won");
                Map <Integer, ArrayList<GameSquare>> utilityVal = new HashMap();
                int terminalVal = (playerWins) ? -100 : 100; // the player in this case is the enemy
                utilityVal.put(new Integer(terminalVal), null);
                return utilityVal;
            }
               
//            System.out.println("MIN_FUNC: getting deep copy");

            for (Map.Entry<Point,GameSquare> intialEntry : currentPiecesState.entrySet()){
                GameSquare oldLoc = intialEntry.getValue().clone();
                LinkedHashMap<GameSquare, Boolean> possibleMovesForSquare = getListOfPossibleMoves(oldLoc, copiedPlayerPieces, copiedEnemyPieces, copiedSquares);
                for (GameSquare newLoc : possibleMovesForSquare.keySet()){
                    GameSquare newLocUntouched = newLoc.clone();
//                    System.out.println("Inside MIN_FUNC Loop");
                    defaultMove.clear(); // clear default move
                    oldLoc = intialEntry.getValue().clone();
                    copiedPlayerPieces = getDeepCopy(intialStateOfPieces);
                    copiedEnemyPieces  = getDeepCopy(intialStateOfEnemyPieces);
                    copiedSquares      = getDeepCopy(intialStateOfSquares);
    //            v ← MAX(v, MIN-VALUE(RESULT(state, a), α, β, depth+1))
                    
                    moveWithoutUpdatingGUI(oldLoc, newLoc, copiedPlayerPieces, copiedEnemyPieces, copiedSquares);
                    copiedPlayerPieces = changedPieces.get(0);
                    copiedEnemyPieces  = changedPieces.get(1);
                    copiedSquares      = changedPieces.get(2);
                    
                    flipConfigsForAIorPlayer(copiedPlayerPieces, copiedEnemyPieces);
                    copiedPlayerPieces = changedPieces.get(0);
                    copiedEnemyPieces  = changedPieces.get(1);
                    
                    Map<Integer, ArrayList<GameSquare>> resultOfMax = MAX_VALUE(copiedPlayerPieces, copiedEnemyPieces, copiedSquares, alpha, beta, depth+1); // get the resulting v value & move to get that value for the min player
                    
                    flipConfigsForAIorPlayer(copiedPlayerPieces, copiedEnemyPieces);
                    copiedPlayerPieces = changedPieces.get(0);
                    copiedEnemyPieces  = changedPieces.get(1);
                    
                    Map.Entry<Integer, ArrayList<GameSquare>> entry = resultOfMax.entrySet().iterator().next(); // extract the v value from the pair returned
                    int returnValOfMAX_VALUE = entry.getKey().intValue();
                    
                    v = Math.min(v, returnValOfMAX_VALUE); // do the comparison
                    // should I reset the player, enemy, and all squares before running this again?

                    oldLoc = intialEntry.getValue().clone();
                    newLoc = newLocUntouched;
    //                if v ≤ α then return v
                    if (v <= alpha){
                        ArrayList<GameSquare> moveToMake = new ArrayList<>(Arrays.asList(oldLoc, newLoc));
                        Map <Integer, ArrayList<GameSquare>> pairToReturn = new HashMap();
                        pairToReturn.put(v, moveToMake);
                        return pairToReturn;
                    }
    //                α← MAX(α, v)
                    beta = Math.min(beta, v); 
                    defaultMove.add(oldLoc);
                    defaultMove.add(newLoc);
                }
            }
        }catch (Exception e){
            System.out.println("***************************************");
            System.out.println("ERROR in MIN_FUNC");
            System.out.println("Issue:  "+ e);
            System.out.println("PlayerColor: " + playerColor);
            System.out.println(playerPieces);
            System.out.println("EnemyColor: " + playerColor);
            System.out.println(enemyPieces);
            System.out.println("***************************************");
        }
        
        
        Map <Integer, ArrayList<GameSquare>> pairToReturn = new HashMap();
        pairToReturn.put(v, defaultMove);
        return pairToReturn;
        
    }
// v ← MAX(v, MIN-VALUE(RESULT(state, a), α, β, depth+1))
// if v ≥ β then return v
// α← MAX(α, v)
// return v
// 
    
    
    public void setActionForAllSquares(){
        for (JButton square : squares.values()){
            square.addActionListener(new SquareMovement());
        }
    }
    
    public void setChoicesForPlayerColorChoice(){
        playerColorChoice.addItem("White");
        playerColorChoice.addItem("Black");
        playerColorChoice.addItemListener(new ChoiceListener());
    }
    
    public static void setPlayerColorChoice(String color){
        playerColor = color;
    }
    
    public static String getPlayerColor(){
        return playerColor;
    }
    
    public static Boolean isPointAnEnemy(Point point, Set points){
        return points.contains(point);
    }
    public static int incrementIfPointIsPiece(Point currentPoint, int numOfPieces, LinkedHashMap<Point, GameSquare> copiedSquares){
        if (copiedSquares.containsKey(currentPoint)){
            if (copiedSquares.get(currentPoint).isPiece())
                numOfPieces++;
        }
        return numOfPieces;
    }
    
    public static int getNumOfHorizontalPieces(GameSquare currentSquare, LinkedHashMap<Point, GameSquare> copiedSquares){
        
        int currentCol = currentSquare.getRelativeY();
        int currentRow = currentSquare.getRelativeX();
        int numOfPiecesInHorizontal = 0;
        
        // count up from current square to edge & get total num of pieces in direction
        while (currentCol < COLUMNS){
            Point currentPoint = new Point(currentRow, currentCol);
            numOfPiecesInHorizontal = incrementIfPointIsPiece(currentPoint, numOfPiecesInHorizontal, copiedSquares);
            currentCol++;
        }
        
        // count down from current square to edge & get total num of pieces in direction
        currentCol = currentSquare.getRelativeY();  
        while (currentCol > 0){
            currentCol--;     
            Point currentPoint = new Point(currentRow, currentCol);
            numOfPiecesInHorizontal = incrementIfPointIsPiece(currentPoint, numOfPiecesInHorizontal, copiedSquares);
        }
        
        return numOfPiecesInHorizontal;
        
    }
    
    public static int getNumOfVerticalPieces(GameSquare currentSquare, LinkedHashMap<Point, GameSquare> copiedSquares){
        int currentCol = currentSquare.getRelativeY();
        int currentRow = currentSquare.getRelativeX();
        int numOfVerticalPieces = 0;
        
        // count up from current square to edge & get total num of pieces in direction
        while (currentRow < ROWS){
            Point currentPoint = new Point(currentRow, currentCol);
            numOfVerticalPieces = incrementIfPointIsPiece(currentPoint, numOfVerticalPieces, copiedSquares);
            currentRow++;
        }
        
        // count down from current square to edge & get total num of pieces in direction
        currentRow = currentSquare.getRelativeX();  
        while (currentRow > 0){
            currentRow--;     
            Point currentPoint = new Point(currentRow, currentCol);
            numOfVerticalPieces = incrementIfPointIsPiece(currentPoint, numOfVerticalPieces, copiedSquares);
        }
        
        return numOfVerticalPieces;
    }
    
    public static int getNumOfDiagonalPieces(GameSquare currentSquare, String diagonalDirection, LinkedHashMap<Point, GameSquare> copiedSquares){
        int currentCol = currentSquare.getRelativeY();
        int currentRow = currentSquare.getRelativeX();
        int numOfDiagonalPieces = 0;
        Boolean isTopLeftToBottomRightSearch = false;
        Boolean isBottomLeftToTopRightSearch = false;
      
        switch(diagonalDirection){
            case "topLeftToBottomRight":
                isTopLeftToBottomRightSearch = true;
                break;
            case "bottomLeftToTopRight":
                isBottomLeftToTopRightSearch = true;
                break;
        }
        
        if (isTopLeftToBottomRightSearch){
            while (currentRow < ROWS && currentCol < COLUMNS){
                Point currentPoint = new Point(currentRow, currentCol);
                numOfDiagonalPieces = incrementIfPointIsPiece(currentPoint, numOfDiagonalPieces, copiedSquares);
                currentRow++; currentCol++;
            }
        }
        
        if (isTopLeftToBottomRightSearch){
            currentRow = currentSquare.getRelativeX();  
            currentCol = currentSquare.getRelativeY();
            while (currentRow > 0 && currentCol > 0){
                currentRow--;  currentCol--;
                Point currentPoint = new Point(currentRow, currentCol);
                numOfDiagonalPieces = incrementIfPointIsPiece(currentPoint, numOfDiagonalPieces, copiedSquares);
            }
        }
        
        if (isBottomLeftToTopRightSearch){
            currentRow = currentSquare.getRelativeX();  
            currentCol = currentSquare.getRelativeY();
            while (currentRow >= 0 && currentCol < COLUMNS){  
                Point currentPoint = new Point(currentRow, currentCol);
                numOfDiagonalPieces = incrementIfPointIsPiece(currentPoint, numOfDiagonalPieces, copiedSquares);
                currentRow--;  currentCol++;  
            }
        }
        
        if (isBottomLeftToTopRightSearch){
            currentRow = currentSquare.getRelativeX();  
            currentCol = currentSquare.getRelativeY();
            while (currentRow < (ROWS-1) && currentCol > 0){   
                currentRow++;  currentCol--; 
                Point currentPoint = new Point(currentRow, currentCol);
                numOfDiagonalPieces = incrementIfPointIsPiece(currentPoint, numOfDiagonalPieces, copiedSquares); 
            }
        }
        return numOfDiagonalPieces;
    }
    
    // TODO - think about switching the check num of pieces in diff directions to simply looping through the players arrayList
    public static void getValidMovesInHorizontal(GameSquare piece, int numOfHorizontalPieces, LinkedHashMap<GameSquare, Boolean> validMoves,
                                                 LinkedHashMap<Point, GameSquare> copiedPlayers,
                                                 LinkedHashMap<Point, GameSquare> copiedEnemies,
                                                 LinkedHashMap<Point, GameSquare> copiedSquares){
        int currentCol = piece.getRelativeY();
        int currentRow = piece.getRelativeX();
//        if(playerColor.equals("White"))
//                System.out.println("Color is: " + playerColor);
        // check if friendly in location - BAD
        int rightBoundary = currentCol + numOfHorizontalPieces;
        int leftBoundary  = currentCol - numOfHorizontalPieces;
        rightBoundary = (rightBoundary > (COLUMNS-1)) ? -1 : rightBoundary;
        leftBoundary  = (leftBoundary < 0) ? -1 : leftBoundary;
        
        Point rightMove, leftMove;
        if (rightBoundary != -1)
            rightMove = new Point(currentRow, rightBoundary);
        else
            rightMove = null;
        
        if (leftBoundary != -1)
            leftMove  = new Point(currentRow, leftBoundary);
        else 
            leftMove = null;
        
        if (copiedPlayers.containsKey(rightMove))
            rightMove = null;
        if (copiedPlayers.containsKey(leftMove))
            leftMove = null;
        
        if (!((rightMove==null) && (leftMove==null)) ){ // checking to see if they 
            // check if enemies in the way to the location - BAD
            currentCol--; 
            while(currentCol > leftBoundary && (leftMove != null)){
                Point currentPoint = new Point(currentRow, currentCol);
                if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                    leftMove = null;
                    break;
                }
                currentCol--;
            }
            
            currentCol = piece.getRelativeY();
            currentCol++;
            while(currentCol < rightBoundary && (rightMove != null)){
                Point currentPoint = new Point(currentRow, currentCol);
                if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                    rightMove = null;
                    break;
                }
                currentCol++;
            }
            
            if ( (rightMove == null) && (leftMove == null) )
                return;
            
            // check if Enemy in location - doesn't really matter at this point... just make sure to check when moving so the GUI can be updated accordingly
            if (leftMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(leftMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(leftMove), isEnemyInLoc);
            }
                    
            if (rightMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(rightMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(rightMove), isEnemyInLoc);
            } 
        }
    }
    
    public static void getValidMovesInVertical(GameSquare piece, int numOfVerticalPieces, LinkedHashMap<GameSquare, Boolean> validMoves,
                                               LinkedHashMap<Point, GameSquare> copiedPlayers,
                                               LinkedHashMap<Point, GameSquare> copiedEnemies,
                                               LinkedHashMap<Point, GameSquare> copiedSquares){
        int currentCol = piece.getRelativeY();
        int currentRow = piece.getRelativeX();
//        if(playerColor.equals("White"))
//                System.out.println("Color is: " + playerColor);
        // check if friendly in location - BAD
        int bottomBoundary = currentRow + numOfVerticalPieces;
        int topBoundary    = currentRow - numOfVerticalPieces;
        bottomBoundary = (bottomBoundary > (ROWS-1)) ? -1 : bottomBoundary;
        topBoundary  = (topBoundary < 0) ? -1 : topBoundary;
        
        Point topMove, bottomMove;
        if (topBoundary != -1)
            topMove = new Point(topBoundary, currentCol);
        else
            topMove = null;
        
        if (bottomBoundary != -1)
            bottomMove  = new Point(bottomBoundary, currentCol);
        else 
            bottomMove = null;
        
        if (copiedPlayers.containsKey(topMove))
            topMove = null;
        if (copiedPlayers.containsKey(bottomMove))
            bottomMove = null;
        
        if (!((topMove==null) && (bottomMove==null)) ){ // checking to see if they 
            // check if enemies in the way to the location - BAD
            currentRow--; 
            while(currentRow > topBoundary && (topMove != null)){
                Point currentPoint = new Point(currentRow, currentCol);
                if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                    topMove = null;
                    break;
                }
                currentRow--;
            }
            
            currentRow = piece.getRelativeX();
            currentRow++;
            while(currentRow < bottomBoundary && (bottomMove != null)){
                Point currentPoint = new Point(currentRow, currentCol);
                if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                    bottomMove = null;
                    break;
                }
                currentRow++;
            }
            
            if ( (bottomMove == null) && (topMove == null) )
                return;
            
            // check if Enemy in location - doesn't really matter at this point... just make sure to check when moving so the GUI can be updated accordingly
            if (topMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(topMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(topMove), isEnemyInLoc);
            }
                    
            if (bottomMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(bottomMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(bottomMove), isEnemyInLoc);
            } 
        }
    }

    public static void getValidMovesInDiagonal(GameSquare piece, int numOfDiagonalPieces, LinkedHashMap<GameSquare, Boolean> validMoves, String diagonalDirection,
                                                LinkedHashMap<Point, GameSquare> copiedPlayers,
                                                LinkedHashMap<Point, GameSquare> copiedEnemies,
                                                LinkedHashMap<Point, GameSquare> copiedSquares){
        int currentCol = piece.getRelativeY();
        int currentRow = piece.getRelativeX();
        Boolean isTopRightSearch    = false;
        Boolean isBottomRightSearch = false;
        Boolean isBottomLeftSearch  = false;
        Boolean isTopLeftSearch     = false;
        
        Boolean isTopLeftToBottomRightSearch    = false;
        Boolean isBottomLeftToTopRightSearch = false;
      
        switch(diagonalDirection){
            case "topLeftToBottomRight":
                isTopLeftToBottomRightSearch = true;
                break;
            case "bottomLeftToTopRight":
                isBottomLeftToTopRightSearch = true;
                break;
        }
        
        if (isTopLeftToBottomRightSearch){
            isTopLeftSearch     = true;
            isBottomRightSearch = true;
        }
            
        if (isBottomLeftToTopRightSearch){
            isTopRightSearch     = true;
            isBottomLeftSearch   = true;
        }

        int highBoundedCol = 0; 
        int lowBoundedCol  = 0;
        int highBoundedRow = 0;
        int lowBoundedRow  = 0;
        
//        highBoundedCol = (highBoundedCol > (COLUMNS-1)) ? -1 : highBoundedCol;
//        lowBoundedCol  = (lowBoundedCol < 0)            ? -1 : lowBoundedCol;
//        
//        highBoundedRow = (highBoundedRow > (ROWS-1)) ? -1 : highBoundedRow;
//        lowBoundedRow  = (lowBoundedRow < 0)         ? -1 : lowBoundedRow;
        
        if(isTopRightSearch || isBottomRightSearch){
            highBoundedCol = currentCol + numOfDiagonalPieces;
            highBoundedCol = (highBoundedCol > (COLUMNS-1)) ? -1 : highBoundedCol;
        }
        
        if (isBottomRightSearch || isBottomLeftSearch){
            highBoundedRow = currentRow + numOfDiagonalPieces;
            highBoundedRow = (highBoundedRow > (ROWS-1)) ? -1 : highBoundedRow;
        }
        
        if (isTopRightSearch || isTopLeftSearch){
            lowBoundedRow  = currentRow - numOfDiagonalPieces;
            lowBoundedRow  = (lowBoundedRow < 0) ? -1 : lowBoundedRow;
        }
        
        if (isTopLeftSearch || isBottomLeftSearch){
            lowBoundedCol  = currentCol - numOfDiagonalPieces;
            lowBoundedCol  = (lowBoundedCol < 0) ? -1 : lowBoundedCol;
        }
        
        Point topLeftMove     = null;
        Point topRightMove    = null;
        Point bottomRightMove = null; 
        Point bottomLeftMove  = null;
        
        if (isTopRightSearch){
            if ( highBoundedCol != -1 && lowBoundedRow != -1 )
                topRightMove = new Point(lowBoundedRow, highBoundedCol);
            else
                topRightMove = null;
        }
        
        if (isBottomRightSearch){
            currentRow = piece.getRelativeX();  
            currentCol = piece.getRelativeY();
            if ( highBoundedCol != -1 && highBoundedRow != -1 )
                bottomRightMove  = new Point(highBoundedRow, highBoundedCol);
            else 
                bottomRightMove = null;
        }
        if (isTopLeftSearch){
            currentRow = piece.getRelativeX();  
            currentCol = piece.getRelativeY();
            if ( lowBoundedCol != -1 && lowBoundedRow != -1 )
                topLeftMove = new Point(lowBoundedRow, lowBoundedCol);
            else
                topLeftMove = null;
        }
        
        if (isBottomLeftSearch){
            currentRow = piece.getRelativeX();  
            currentCol = piece.getRelativeY();
            if ( lowBoundedCol != -1 && highBoundedRow != -1 )
                bottomLeftMove = new Point(highBoundedRow, lowBoundedCol);
            else
                bottomLeftMove = null;
        }
        
        if (copiedPlayers.containsKey(topRightMove))
            topRightMove = null;
        if (copiedPlayers.containsKey(bottomRightMove))
            bottomLeftMove = null;
        if (copiedPlayers.containsKey(bottomLeftMove))
            bottomLeftMove = null;
        if (copiedPlayers.containsKey(topLeftMove))
            bottomLeftMove = null;
        
        if (!((topRightMove==null) && (bottomRightMove==null) && (bottomLeftMove==null) && (topLeftMove==null)) ){ // checking to see if they 
            // check if enemies on the way to topRight loc
            
            if (topRightMove != null){
                currentRow--;
                currentCol++;
                while( (currentCol < highBoundedCol) && (currentRow > lowBoundedRow)){
                    Point currentPoint = new Point(currentRow, currentCol);
                    if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                        topRightMove = null;
                        break;
                    }
                    currentRow--;
                    currentCol++;
                }
            }
            
            // checking if enemies exist on path to bottomRight
            if (bottomRightMove != null){
                currentRow++;
                currentCol++;
                while( (currentCol < highBoundedCol) && (currentRow < highBoundedRow)){
                    Point currentPoint = new Point(currentRow, currentCol);
                    if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                        topRightMove = null;
                        break;
                    }
                    currentRow++;
                    currentCol++;
                }
            }
            
            // checking if enemies exist on path to bottomLeft
            if (bottomLeftMove != null){
                currentRow++;
                currentCol--;
                while( (currentCol > lowBoundedCol) && (currentRow < highBoundedRow)){
                    Point currentPoint = new Point(currentRow, currentCol);
                    if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                        topRightMove = null;
                        break;
                    }
                    currentRow++;
                    currentCol--;
                }
            }
            
            // checking if enemies exist on path to topLeft
            if (topLeftMove != null){
                currentRow--;
                currentCol--;
                while( (currentCol > lowBoundedCol) && (currentRow > lowBoundedRow)){
                    Point currentPoint = new Point(currentRow, currentCol);
                    if(isPointAnEnemy(currentPoint, copiedEnemies.keySet())){ // cannot jump enemy
                        topRightMove = null;
                        break;
                    }
                    currentRow--;
                    currentCol--;
                }
            }     
            
            if ( (topRightMove==null) && (bottomRightMove==null) && (bottomLeftMove==null) && (topLeftMove==null) )
                return;
            
            // check if Enemy in location - doesn't really matter at this point... just make sure to check when moving so the GUI can be updated accordingly
            if (topRightMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(topRightMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(topRightMove), isEnemyInLoc);
            }
                    
            if (bottomRightMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(bottomRightMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(bottomRightMove), isEnemyInLoc);
            } 
            
            if (bottomLeftMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(bottomLeftMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(bottomLeftMove), isEnemyInLoc);
            } 
            
            if (topLeftMove != null){
                Boolean isEnemyInLoc = (isPointAnEnemy(topLeftMove, copiedEnemies.keySet())) ? true : false;
                validMoves.put(copiedSquares.get(topLeftMove), isEnemyInLoc);
            } 
        }
    }
 
    /*
    public static LinkedHashMap<GameSquare, Boolean> getListOfPossibleMoves(GameSquare currentSquare){
        LinkedHashMap<GameSquare, Boolean> validMoves = new LinkedHashMap<>();
        int numHorizontalCheckers = getNumOfHorizontalPieces(currentSquare);
        int numVerticalCheckers   = getNumOfVerticalPieces(currentSquare);
        int numTopRightDiagonalCheckers      = getNumOfDiagonalPieces(currentSquare, "topLeftToBottomRight");
        int numBottomRightDiagonalCheckers   = getNumOfDiagonalPieces(currentSquare, "bottomLeftToTopRight");
        
        getValidMovesInHorizontal(currentSquare, numHorizontalCheckers, validMoves);
        getValidMovesInVertical(currentSquare,   numVerticalCheckers,   validMoves);
        getValidMovesInDiagonal(currentSquare,   numTopRightDiagonalCheckers,    validMoves, "topLeftToBottomRight");
        getValidMovesInDiagonal(currentSquare,   numBottomRightDiagonalCheckers, validMoves, "bottomLeftToTopRight");
        
//        System.out.println("--------");
//        System.out.println("List of Valid Moves...");
//        for (GameSquare square : validMoves.keySet()){
//           System.out.println("Sqaure Loc: " + square.getRelativeLoc() + " color: " + square.pieceColor());
//        }
        return validMoves;
    }
    */
    
        public static LinkedHashMap<GameSquare, Boolean> getListOfPossibleMoves(GameSquare currentSquare,
                                                                                     LinkedHashMap<Point, GameSquare> copiedPlayers,
                                                                                     LinkedHashMap<Point, GameSquare> copiedEnemies,
                                                                                     LinkedHashMap<Point, GameSquare> copiedSquares){
        LinkedHashMap<GameSquare, Boolean> validMoves = new LinkedHashMap<>();
        int numHorizontalCheckers = getNumOfHorizontalPieces(currentSquare, copiedSquares);
        int numVerticalCheckers   = getNumOfVerticalPieces(currentSquare, copiedSquares);
        int numTopRightDiagonalCheckers      = getNumOfDiagonalPieces(currentSquare, "topLeftToBottomRight", copiedSquares);
        int numBottomRightDiagonalCheckers   = getNumOfDiagonalPieces(currentSquare, "bottomLeftToTopRight", copiedSquares);
        
        getValidMovesInHorizontal(currentSquare, numHorizontalCheckers, validMoves, copiedPlayers, copiedEnemies, copiedSquares);
        getValidMovesInVertical(currentSquare,   numVerticalCheckers,   validMoves, copiedPlayers, copiedEnemies, copiedSquares);
        getValidMovesInDiagonal(currentSquare,   numTopRightDiagonalCheckers,    validMoves, "topLeftToBottomRight", copiedPlayers, copiedEnemies, copiedSquares);
        getValidMovesInDiagonal(currentSquare,   numBottomRightDiagonalCheckers, validMoves, "bottomLeftToTopRight", copiedPlayers, copiedEnemies, copiedSquares);
        
//        System.out.println("--------");
//        System.out.println("List of Valid Moves...");
//        for (GameSquare square : validMoves.keySet()){
//           System.out.println("Sqaure Loc: " + square.getRelativeLoc() + " color: " + square.pieceColor());
//        }
        return validMoves;
    }
    
    public static void setGrayBoxPropertiesFor(GameSquare oldLoc){
        oldLoc.markSquareAsEmpty();
        oldLoc.setText("");
        oldLoc.setPieceColor("none");
        oldLoc.setBackground(Color.LIGHT_GRAY);
    }
    
    public static void setGrayPropertiesWithoutUpdatingGUIFor(GameSquare oldLoc){
        oldLoc.markSquareAsEmpty();
        oldLoc.setPieceColor("none");
    }
    
    public static void updateBoxColoring(GameSquare oldLoc, GameSquare newLoc){
        newLoc.setBackground(oldLoc.getBackground());
        newLoc.setText(oldLoc.getText());
//        newLoc.setRelativeLoc(oldLoc.getRelativeX(), oldLoc.getRelativeY()); The new loc should retain its own location 
        newLoc.setPieceColor(oldLoc.pieceColor());
        newLoc.makeSquarePlayer();
        setGrayBoxPropertiesFor(oldLoc);
    }
    
    public static void updateBoxColorPropertiesNotGUI(GameSquare oldLoc, GameSquare newLoc){
        newLoc.setPieceColor(oldLoc.pieceColor());
        newLoc.makeSquarePlayer();
        setGrayBoxPropertiesFor(oldLoc);
    }
    
    public static void updateAllSquares(Point pt, GameSquare square){
        squares.put(pt, square);
    }
    
    public static void updateAllCopiedSquares(Point pt, GameSquare square, LinkedHashMap<Point, GameSquare> copiedSquares){
        copiedSquares.put(pt, square);
    }
    
    public static void move(GameSquare oldLoc, GameSquare newLoc){
        // Assumes the movement from old to new locations is valid... will only check to see if the movement is eating another player or not
        
        // handle player to enemy loc
//        Boolean playerEatingEnemy = SquareMovement.isEnemy(newLoc);
//        if (playerEatingEnemy){
//            int playersEatCount = (oldLoc.pieceColor().equals("White")) ? numPiecesWhiteAte : numPiecesBlackAte;
//            playersEatCount++;
//            enemyPieces.remove(newLoc);
//        }
        
        Boolean playerEatingEnemy = enemyPieces.containsKey(newLoc.getRelativeLoc());
        if (playerEatingEnemy){
            int playersEatCount = (oldLoc.pieceColor().equals("White")) ? numPiecesWhiteAte : numPiecesBlackAte;
            playersEatCount++;
            enemyPieces.remove(newLoc.getRelativeLoc());
        }
        
        
        playerPieces.remove(oldLoc.getRelativeLoc());
        playerPieces.put(newLoc.getRelativeLoc(), newLoc);
        
        updateBoxColoring(oldLoc, newLoc);
        
        updateAllSquares(oldLoc.getRelativeLoc(), oldLoc);
        updateAllSquares(newLoc.getRelativeLoc(), newLoc);
        
        // player to empty spot
    }
    
    public static void moveWithoutUpdatingGUI(GameSquare oldLoc, GameSquare newLoc, LinkedHashMap<Point, GameSquare> copiedPlayerPieces, LinkedHashMap<Point, GameSquare> copiedEnemyPieces, LinkedHashMap<Point, GameSquare> copiedSquares){
        System.out.println("Moving piece without GUI ");
        Boolean playerEatingEnemy = copiedEnemyPieces.containsKey(newLoc.getRelativeLoc());
        if (playerEatingEnemy){
            int playersEatCount = (oldLoc.pieceColor().equals("White")) ? numPiecesWhiteAte : numPiecesBlackAte;
            playersEatCount++;
            copiedEnemyPieces.remove(newLoc.getRelativeLoc());
        }
        
        copiedPlayerPieces.remove(oldLoc.getRelativeLoc());
        copiedPlayerPieces.put(newLoc.getRelativeLoc(), newLoc);
        updateBoxColorPropertiesNotGUI(oldLoc, newLoc);
        updateAllCopiedSquares(oldLoc.getRelativeLoc(), oldLoc, copiedSquares);
        updateAllCopiedSquares(newLoc.getRelativeLoc(), newLoc, copiedSquares);
        
        changedPieces.clear();
        changedPieces.add(copiedPlayerPieces);
        changedPieces.add(copiedEnemyPieces); 
        changedPieces.add(copiedSquares);
        
    }
    
    public static synchronized Boolean checkIfNeighboringPiecesAreSameColor(Point point, LinkedHashMap<Point, Boolean> pieces, int numPiecesExplored){
        Point left        = new Point ((int) point.getX() , (int) point.getY() - 1);
        Point right       = new Point ((int) point.getX() , (int) point.getY() + 1);
        Point top         = new Point ((int) point.getX() - 1 , (int) point.getY());
        Point bottom      = new Point ((int) point.getX() + 1 , (int) point.getY());
        Point topLeft     = new Point ((int) point.getX() - 1 , (int) point.getY() - 1);
        Point topRight    = new Point ((int) point.getX() - 1 , (int) point.getY() + 1);  
        Point bottomRight = new Point ((int) point.getX() + 1 , (int) point.getY() + 1);  
        Point bottomLeft  = new Point ((int) point.getX() + 1 , (int) point.getY() - 1); 
        Boolean isAllTrue = false;
        
        for (Point currentPoint : pieces.keySet()){
            if (!pieces.get(currentPoint).equals(true)){
                isAllTrue = false;
                break;
            }
            isAllTrue = true;
        }
        
        if (isAllTrue)
            return true;
        
        Boolean neighborIsFriendly = false;
        numPiecesExplored++;
        if (pieces.containsKey(left)        || 
            pieces.containsKey(right)       ||
            pieces.containsKey(top)         || 
            pieces.containsKey(bottom)      || 
            pieces.containsKey(topLeft)     || 
            pieces.containsKey(topRight)    || 
            pieces.containsKey(bottomRight) ||
            pieces.containsKey(bottomLeft)){
            
            pieces.put(point, true); // piece has a neighbor of the same color
            
        }else
            return false;
        
        if (pieces.containsKey(left) && pieces.get(left).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(left, pieces, numPiecesExplored);
        
        if (pieces.containsKey(right) && pieces.get(right).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(right, pieces, numPiecesExplored);
        
        if (pieces.containsKey(top) && pieces.get(top).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(top, pieces, numPiecesExplored);
        
        if (pieces.containsKey(bottom) && pieces.get(bottom).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(bottom, pieces, numPiecesExplored);
        
        if (pieces.containsKey(topLeft) && pieces.get(topLeft).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(topLeft, pieces, numPiecesExplored);
        
        if (pieces.containsKey(topRight) && pieces.get(topRight).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(topRight, pieces, numPiecesExplored);
        
        if (pieces.containsKey(bottomRight) && pieces.get(bottomRight).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(bottomRight, pieces, numPiecesExplored);
        
        if (pieces.containsKey(bottomLeft) && pieces.get(bottomLeft).equals(false))
            neighborIsFriendly = checkIfNeighboringPiecesAreSameColor(bottomLeft, pieces, numPiecesExplored);
        
//        if (numPiecesExplored != pieces.size()) // piece is not attainable from current config
//            return false;
        
        for (Point currentPoint : pieces.keySet()){
            if (!pieces.get(currentPoint).equals(true)){
                isAllTrue = false;
                break;
            }
            isAllTrue = true;
        }
        
        if (isAllTrue)
            return true;
        
        return false;
    }
    
    public static synchronized void checkForWinningGameState(LinkedHashMap<Point, GameSquare> pieces, LinkedHashMap<Point, GameSquare> enemies){
        // Assume no player has won yet
        playerWins = false;
        enemyWins = false;
        
        // if player has 1 piece left
        if (pieces.size()==1){
            playerWins = true;
            return;
        }
        // If enemy has 1 piece left
        if (enemies.size()==1){
            enemyWins = true;
            return;
        }
        
        // If there are no player pieces left, the game should still continue if there are enemy pieces
        if (pieces.size() <= 0){
            return;
        }
        
        // Check to see if the player's pieces are in a contigous body
        // the checkIfNeighboringPiecesAreSameColor function performs the check logic
        LinkedHashMap<Point, Boolean> playerPiecesToExplore = new LinkedHashMap();
        for (Point point : pieces.keySet())
            playerPiecesToExplore.put(point, false);
        int timesChecked = 0;
        
        Map.Entry<Point, Boolean> entry = playerPiecesToExplore.entrySet().iterator().next();
        Point point = entry.getKey();

        playerWins = checkIfNeighboringPiecesAreSameColor(point, playerPiecesToExplore, 0);
        
        // If no enemies are left, the player can still win
        if (enemies.size() <=0 ){
            return;
        }
        
        // check if enemy has won
        // Check to see if the enemy's pieces are in a contigous body
        // the checkIfNeighboringPiecesAreSameColor function performs the check logic
        LinkedHashMap<Point, Boolean> enemyPiecesToExplore = new LinkedHashMap();
        for (Point enemyPoint : enemies.keySet())
            enemyPiecesToExplore.put(enemyPoint, false);
        
        entry = enemyPiecesToExplore.entrySet().iterator().next();
        point = entry.getKey();
            enemyWins = checkIfNeighboringPiecesAreSameColor(point, enemyPiecesToExplore, 0);
    }
    
    public void setAllInitialRelativeLoc(){
        // This function will intialize the location of each square in the grid
        // Below is a view of the grid
        /*
         (0,0) (0,1) (0,2) (0,3) (0,4)
         (1,0) (1,1) (1,2) (1,3) (1,4)
         (2,0) (2,1) (2,2) (2,3) (2,4)
         (3,0) (3,1) (3,2) (3,3) (3,4)
         (4,0) (4,1) (4,2) (4,3) (4,4)
        */
        
        // First Row
        square0.setRelativeLoc(0,0);
        square1.setRelativeLoc(0,1);
        square2.setRelativeLoc(0,2);
        square3.setRelativeLoc(0,3);
        square4.setRelativeLoc(0,4);
        
        // Second Row
        square5.setRelativeLoc(1,0);
        square6.setRelativeLoc(1,1);
        square7.setRelativeLoc(1,2);
        square8.setRelativeLoc(1,3);
        square9.setRelativeLoc(1,4);
        
        // Third Row
        square10.setRelativeLoc(2,0);
        square11.setRelativeLoc(2,1);
        square12.setRelativeLoc(2,2);
        square13.setRelativeLoc(2,3);
        square14.setRelativeLoc(2,4);
        
        // Fourth Row
        square15.setRelativeLoc(3,0);
        square16.setRelativeLoc(3,1);
        square17.setRelativeLoc(3,2);
        square18.setRelativeLoc(3,3);
        square19.setRelativeLoc(3,4);
        
        // Fourth Row
        square20.setRelativeLoc(4,0);
        square21.setRelativeLoc(4,1);
        square22.setRelativeLoc(4,2);
        square23.setRelativeLoc(4,3);
        square24.setRelativeLoc(4,4);
    }
    public void storeAllSquaresInArr(){
        // This function will store all of the squares in the grid into a LinkedHashMap that will help keep track of the state of the game
        squares.put(square0.getRelativeLoc(), square0);
        squares.put(square1.getRelativeLoc(), square1);
        squares.put(square2.getRelativeLoc(), square2);
        squares.put(square3.getRelativeLoc(), square3);
        squares.put(square4.getRelativeLoc(), square4);
        squares.put(square5.getRelativeLoc(), square5);
        squares.put(square6.getRelativeLoc(), square6);
        squares.put(square7.getRelativeLoc(), square7);
        squares.put(square8.getRelativeLoc(), square8);
        squares.put(square9.getRelativeLoc(), square9);
        squares.put(square10.getRelativeLoc(), square10);
        squares.put(square11.getRelativeLoc(), square11);
        squares.put(square12.getRelativeLoc(), square12);
        squares.put(square13.getRelativeLoc(), square13);
        squares.put(square14.getRelativeLoc(), square14);
        squares.put(square15.getRelativeLoc(), square15);
        squares.put(square16.getRelativeLoc(), square16);
        squares.put(square17.getRelativeLoc(), square17);
        squares.put(square18.getRelativeLoc(), square18);
        squares.put(square19.getRelativeLoc(), square19);
        squares.put(square20.getRelativeLoc(), square20);
        squares.put(square21.getRelativeLoc(), square21);
        squares.put(square22.getRelativeLoc(), square22);
        squares.put(square23.getRelativeLoc(), square23);
        squares.put(square24.getRelativeLoc(), square24);

    }
    
    public void setInitialPlayers(){
        /* 
        
        Initial White Players Locations: 
               (1,0)     (1,4)    
               (2,0)     (2,4)
               (3,0)     (3,4)
        
        Initial Black Players Locations
               (0,1) (0,2) (0,3)
               (4,1) (4,2) (4,3)
        
        - Each player has a LinkedHashMap that will keep track where each respective player's pieces are 
        - This was done to decrease the search time when looking for valid moves & for checking for a winning state
            - If this wasn't done, the entire game state would need to be searched
        */
        
        // Adding all initial white players
        blackPlayers.put(square1.getRelativeLoc(), square1);
        blackPlayers.put(square2.getRelativeLoc(), square2);
        blackPlayers.put(square3.getRelativeLoc(), square3);
        
        blackPlayers.put(square21.getRelativeLoc(), square21);
        blackPlayers.put(square22.getRelativeLoc(), square22);
        blackPlayers.put(square23.getRelativeLoc(), square23);
        
        // Adding all initial black players
        whitePlayers.put(square5.getRelativeLoc(), square5);
        whitePlayers.put(square10.getRelativeLoc(), square10);
        whitePlayers.put(square15.getRelativeLoc(), square15);
        
        whitePlayers.put(square9.getRelativeLoc(), square9);
        whitePlayers.put(square14.getRelativeLoc(), square14);
        whitePlayers.put(square19.getRelativeLoc(), square19);
        
        for (GameSquare whitePlayer : whitePlayers.values()){
            whitePlayer.makeSquarePlayer();
            whitePlayer.setPieceColor("White");
        }
        
        for (GameSquare blackPlayer : blackPlayers.values()){
            blackPlayer.makeSquarePlayer();
            blackPlayer.setPieceColor("Black");
        }
        
    }
    
    public static void setCorrespondingGameConfigs(){
        /*
        - This function should fire off after the player chooses hes/her color of choice
        - This function will assing the corresponding "playerPieces" and "enemyPieces" respectively based on the player's color choice
        - The enemy color will also be set
        - i.e. If I choose to be White, then the enemy will be set to Black, and its pieces will be the inital state of the black pieces
        */
        playerPieces = (playerColor.equals("White")) ? whitePlayers : blackPlayers;
        enemyPieces  = (playerColor.equals("White")) ? blackPlayers : whitePlayers;
        enemyColor   = (playerColor.equals("White")) ? "Black" : "White";
    }
    
    
    public static LinkedHashMap<Point, GameSquare> getDeepCopy(LinkedHashMap<Point, GameSquare> source) throws CloneNotSupportedException{
        // This will be used to make deeep copies of the player & enemy pieces, and the gameboard when running the Alpha Beta Algorithm
        // This is necessary so that recrusive runs do not affect objects stored in caller's env
    LinkedHashMap<Point, GameSquare> copy = new LinkedHashMap<Point, GameSquare>();
    for (Map.Entry<Point, GameSquare> entry : source.entrySet())
        copy.put(entry.getKey(), entry.getValue().clone());
    return copy;
    }
    
//    public static void playerMoved(){
//        // flag used in the main function to determine whether or not the player has made a move
//        playerMoved = true;
//    }
//    
//    public static void resetPlayer(){
//        // called after the player has moved & will indicate thatit's time for the Alpha-Beta Algo to run
//        playerMoved = false;
//    }
    
    public static LinkedHashMap<Point, GameSquare> getPlayerPieces(){
        // returns the current player pieces 
        return playerPieces;
    }
    
    public static LinkedHashMap<Point, GameSquare> getEnemyPieces(){
        // returns the current enemy pieces
        return enemyPieces;
    }
    
    public static LinkedHashMap<Point, GameSquare> getSquares(){
        // returns the current gameboard
        return squares;
    }
    
    public static Boolean didPlayerWin(){
        // returns whether or not the player has won
        return playerWins;
    }
    
    public static Boolean didEnemyWin(){
        // returns whether or not the enemy has won
        return enemyWins;
    }

    // All variable declarations... some were generated via the Netbeans GUI Editor
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Choice choice1;
    private javax.swing.JPanel jPanel1;
    private java.awt.Label label1;
    private java.awt.Choice playerColorChoice;
    private ai.project.GameSquare square0;
    private ai.project.GameSquare square1;
    private ai.project.GameSquare square10;
    private ai.project.GameSquare square11;
    private ai.project.GameSquare square12;
    private ai.project.GameSquare square13;
    private ai.project.GameSquare square14;
    private ai.project.GameSquare square15;
    private ai.project.GameSquare square16;
    private ai.project.GameSquare square17;
    private ai.project.GameSquare square18;
    private ai.project.GameSquare square19;
    private ai.project.GameSquare square2;
    private ai.project.GameSquare square20;
    private ai.project.GameSquare square21;
    private ai.project.GameSquare square22;
    private ai.project.GameSquare square23;
    private ai.project.GameSquare square24;
    private ai.project.GameSquare square3;
    private ai.project.GameSquare square4;
    private ai.project.GameSquare square5;
    private ai.project.GameSquare square6;
    private ai.project.GameSquare square7;
    private ai.project.GameSquare square8;
    private ai.project.GameSquare square9;
    // End of variables declaration//GEN-END:variables
    private static LinkedHashMap<Point,GameSquare> squares = new LinkedHashMap<>(); // current state of the gameboard
    private static LinkedHashMap<Point,GameSquare> whitePlayers  = new LinkedHashMap<>(); // all white player objects
    private static LinkedHashMap<Point,GameSquare> blackPlayers  = new LinkedHashMap<>(); // all black player objects
    private static LinkedHashMap<Point, GameSquare> playerPieces = new LinkedHashMap();   // all player pieces
    private static LinkedHashMap<Point, GameSquare> enemyPieces  = new LinkedHashMap();   // all enemy pieces
    private static LinkedHashMap<Point, GameSquare> savedPlayerPieces = new LinkedHashMap(); // used to save player pieces during an alpha beta run
    private static LinkedHashMap<Point, GameSquare> savedEnemyPieces  = new LinkedHashMap(); // used to save enemy pieces during an alpha beta run
    private static LinkedHashMap<Point, GameSquare> savedGameBoard    = new LinkedHashMap(); // used to save the gameboad state during an alpha beta run
//    private static LinkedHashMap<Point, GameSquare> playerPiecesBeforeRun = new LinkedHashMap(); 
//    private static LinkedHashMap<Point, GameSquare> enemyPiecesBeforeRun = new LinkedHashMap();
    private static ArrayList<LinkedHashMap<Point, GameSquare>> changedPieces = new ArrayList(); // when the player or enemy pieces are changed, the changed data structures are stored in here, and are then use to keep track of the current enemy & player pieces
    private static String playerColor  = "White"; // the color of the player which will change based on if the player is making a move or if the Alpha Beta algorithm is
    private static String enemyColor   = "Black"; // the color of the enemy which will change based on if the player is making a move or if the Alpha Beta algorithm is
    private static Boolean enemyWins   = false;   // denotes whether or not the player has won
    private static Boolean playerWins  = false;   // denotes whether or not an enemy has won
    private static Boolean playerMoved = false;   // denotes wh
    private static int maxDepth = 0;
    private static final int infinity  = 1000;    // the infinity value used with the Alpha Beta Algorithm
    public static Boolean gameOver   = false;     // signals to the game whether or not the game is over
    public static Boolean isFirstRun = true;      // signals to the game if it is the first run of the game
    public static Boolean playerColorChoiceSet = false; // signals to the game whether or not the player has chosen a color as his/her iece
    public static Boolean isPlayerTurn = false;   // signals to the game whether or not it is the player's turn to make a move (not the Algorithm)
    
    public static final int ROWS = 5;    // The number of rows in the game/GUI - ** THIS IS CHANGED FOR THE 6x6 VERSION
    public static final int COLUMNS = 5; // The number of the columns in the game/GUI - ** THIS IS CHANGED FOR THE 6x6 VERSION
    public static int numPiecesWhiteAte = 0; // Used to keep track of the number of pieces white has eaten
    public static int numPiecesBlackAte = 0; // Used to keep track of the number of pieces black has eaten
    public static float startTime = 0;       // The start time used to determine when 10seconds has passed and should intiate the cutoff in the Alpha Beta Algorithm
}

class SquareMovement implements ActionListener {
    // A generic Action Listener that will be associated with EVERY square on the board
    // The actions defined will be used with player actions/interactions with the GUI
    private static Boolean firstClick = true; // says whether or not the specific square has been clicked for the first time
    private static GameSquare previousClickedPiece; // the piece that was clicked prior to the one that will be clicked next... this is imporatnt for moving two pieces
    private static LinkedHashMap<GameSquare, Boolean>  validMoves; // A list of valid moves for a specific piece
    
//    public static Boolean isEnemy(GameSquare piece){
//        // determines if 
//        return validMoves.get(piece);
//    }
    
    @Override
    public void actionPerformed(ActionEvent ae){
        // What will occur for any action on a specific square on the board
        
        if (!GameBoard.playerColorChoiceSet) // Don't do anything if the player has not chosen a color
            return;
        
        GameSquare square = (GameSquare) ae.getSource(); // The square clicked on in the GUI
//        GameBoard.checkForWinningGameState(GameBoard.getPlayerPieces(), GameBoard.getEnemyPieces()); // Checks to see 
//        System.out.println("Player wins: " + GameBoard.getPlayerVictoryStatus());
//        System.out.println("Enemy wins: " + GameBoard.getEnemyVictoryStatus());
        
        if(!(square.pieceColor().equals(GameBoard.getPlayerColor())) && firstClick){ // Fires off if the piece clicked is not the player's piece/color, but is in fact a piece
            System.out.println("Not your color to move... please try again");
            return;
        }
        
        if (square.isPiece() && square.pieceColor().equals(GameBoard.getPlayerColor())){ // The square clicked is a piece (not a gray board piece) & the is the same color the player chose to be
            if (firstClick){
                System.out.println("First click... getting list of possible moves");
                validMoves = GameBoard.getListOfPossibleMoves(square, GameBoard.getPlayerPieces(), GameBoard.getEnemyPieces(), GameBoard.getSquares()); // Gets a list of possible moves for the specific square clicked
                firstClick = false; // Set the flag so that the next square clicked is not stored, but moved to if valid
                // highlight all valid moves... optional (TODO)
                previousClickedPiece = square; // The current square must be stored as the one first clicked on, so that it can be later determined if the next piece clicked on is a valid/not valid move, or if resetting control
                return;
            }else{
                if (square.equals(previousClickedPiece)){ // If you click on the piece that was already clicked, then the control will be reset. This means you are free to click on a new piece all together
                    System.out.println("RESETTING CONTROL...");
//                    GameBoard.resetPlayer();
                    firstClick = true; // Tells the logic above that the next piece clicked is the first time it is being clicked
                    return;
                }
            }

            System.out.println("Not a valid move... click piece to move again"); // Cannot click another piece of your own to move if you have already chosen one to move. To do so, you must click on the original piece you clicked on again to reset the logic
        }
        
        if (firstClick){ // The human clicked on a piece that is not a piece and is not the player's color (i.e. a vacant game square)
            System.out.println("Please click your piece to move");
            return;
        }
        
        
        if (validMoves.containsKey(square)){ // Will fire off if the player has clicked a piece to move, and has now clicked another square to move to & that square is considered to be avalid move 
            System.out.println("Valid Square to move to");   
            GameBoard.move(previousClickedPiece, square); // takes care of the movement of the piece from it's old location to the new location
            // The below will check to to see if someone has won. This also handles the case that when a person moves, and both players in winning state, the player wins
            GameBoard.checkForWinningGameState(GameBoard.getPlayerPieces(), GameBoard.getEnemyPieces()); // After moving the piece, check to see if anyone is in a winning setup on the board
            if (GameBoard.didPlayerWin()){ // checks to see if the player won
                GameBoard.gameOver = true;
                System.out.println("GAME OVER... " + GameBoard.getPlayerColor() + " has won!");
                return;
            }
            if (GameBoard.didEnemyWin()){ // checks to see if the enemy won
                GameBoard.gameOver = true;
                System.out.println("GAME OVER... " + GameBoard.getPlayerColor() + " has won!");
                return;
            }
            GameBoard.isPlayerTurn = false; // tells the main function that the player has made his/her move
            firstClick = true; // resets the GUI logic to wait for user input (his/her first click)
            //move the piece
        }else{
            System.out.println("Not a valid move... please try again or click on the same piece to reset"); // Fires off if the place the user tried to move to is not a valid move
            return;
        }
            
//        System.out.println("Player Color: " + GameBoard.getPlayerColor());
        
        
//        System.out.println("Screen Loc: " +  square.getLocationOnScreen());
//        System.out.println("Screen Loc: " +  square.getRelativeX() + "," + square.getRelativeY());
//        System.out.println("IsPlayer " + square.isPiece());
        
//        getValidMoves(button)
    }
}

class ChoiceListener implements ItemListener{
    // Logic & GUI for user to choose a color 
    @Override
    public void itemStateChanged(ItemEvent e){
        GameBoard.setPlayerColorChoice((String) e.getItem()); // gets the choice the user selected
        Choice colorChoice = (Choice) e.getSource(); // gets the choice the user selected
        colorChoice.setEnabled(false); // gray out the color selector drop-down so that the user cannot change his/her color later in the game
        GameBoard.playerColorChoiceSet = true; // let the game know the user has chosen a color
        GameBoard.setCorrespondingGameConfigs(); // set the configs of the game to correspond with the color the player chose to be
    }
}
